---
sidebar_position: 1
---

# Base Concepts

Meta-System was built from the ground up to be as extensible and modular as possible. If we remove all the built-in extra functionality, Meta-System can be understood as a no-code engine with interfaces for modifying it.

## Theory
As an engine to be capable of powering (almost) any software, Meta-System is required to have a structure capable of representing any software, just as the torque from an engine's axle can have its energy converted, stored, moved and used in hundreds of ways.

The **Data** is contextualized information, such as in a car (context), how many seats there are (information). The **Rules** are logic constraints that apply while acting upon information. For instance, it is not possible to put more seats in a car than what its interior space allows. Lastly, the **Protocols** are the bridge that allows communication with outside the boundaries of the system, be it the internet, a Bluetooth device, a step motor, or even the UI of a fancy app.

With chaining and defining each of this things, it is possible, in theory, to create any system, and that is what we wanted Meta-System to be capable of.

## Key Components

In the Meta-System, the data is called **Schemas**, the rules are called **Business Operations**, and the **Protocols** retained its name.

Shortly explained, by declaring **Schemas**, you are defining the context of informations and assigning it a name, which will be how Meta-System will know the data structure.

Defining the **Business Operations (BOps)** consists in organizing rules and actions in a specific sequence and conditions.

Finally, declaring a **Protocol** means creating an opening for interactions in the external boundaries of the Meta-System.

Those components can be configured to interact with eachother: A **Protocol** communicates to a **Business Operation**, which in its flow and rules, accesses a **Schema** to operate with its data.
## Modularity

The modularity in the Meta-System comes from the decoupled nature of each element (the Schemas, BOps, and Protocols) in its configuration. Although there are many ways to connect them, unless declared, no component depends on another.

### Reusability of BOps, Schemas and Protocols

All those components are reusable once declared. For instance, It is possible to create a BOps `"A"` and another `"B"`, with both of them using the same schema `"Z"` without needing to redeclare the latter.

With a single declaration, BOps can also be used as dependencies for multiple other BOps, which is great for componentization of common logics and, therefore, increases maintainability.

### Modularity Within Business Operations
> Check [Modules Dependencies](../configuring/bops/dependencies) and [Execution Flows](./flows) for a more in-depth explanation of flows and reusing BOps inside another BOps.

Each step of the flow in a Business Operation is a function that chains with the next neighbor to compose the logic of the said flow.

Initially, the functions available to be used are only the built in ones, and those which were generated by a Schema (See Schema BOps Functions). However, Meta-System allows for adding new functions (from NPM packages) directly through the system configuration file. If there is anything that Meta-System currently does not do, you can create any new function that suits your needs, or download compatible solutions from the NPM registry.

We treat this topic more in depth in the [Extending Meta-System Functionality](./extending-functionality) page.
