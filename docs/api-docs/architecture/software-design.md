---
sidebar_position: 1
---

# Software Design Behind Meta-System

Meta-System was built from the ground up to be as extensible and modular as possible. If you strip all the extras and helpers built in, this software can be understood as a function-based flow executor.

## Theory

In order to build a structure capable of representing any software, we needed to come up with a theory. We believe that any system in the world is composed of three things:
- Data
- Rules
- Protocols

The **Data** is contextualized information, such as in a car (context), how many seats there are (information). The **Rules** are logic constraints that apply while acting upon information. For instance, it is not possible to put more seats in a car than what its interior space allows. Lastly, the **Protocols** are the bridge that allows communication with outside the boundaries of the system, be it the internet, a Bluetooth device, a step motor, or even the UI of a fancy app.

With chaining and defining each of this things, it is possible, in theory, to create any system, and that is what we wanted Meta-System to be capable of.

## The Building Blocks

In the Meta-System, the data is called **Schemas**, the rules are called **Business Operations**, and the **Protocols** retained its name.

Shortly explained, by declaring **Schemas**, you are defining the context of informations and assigning it a name, which will be how Meta-System will know the data structure.

Defining the **Business Operations (BOps)** consists in organizing rules and actions in a specific sequence and conditions.

Finally, declaring a **Protocol** means creating an opening for interactions in the external boundaries of the Meta-System.

Those components can be configured to interact with eachother: A **Protocol** communicates to a **Business Operation**, which in its flow and rules, accesses a **Schema** to operate with its data.
## Modularity

The modularity in the Meta-System comes from the decoupled nature of each element (the Schemas, BOps, and Protocols) in its configuration. Although there are many ways to connect them, unless declared, no component depends on another.

### Reusability of BOps and Schemas

Schemas and BOps are reusable once declared. It is possible to create a BOps `"A"` and another `"B"`, with both of them using the same schema `"Z"` without needing to redeclare the latter.

With a single declaration, BOps can also be used as dependencies for multiple other BOps, which is great for componentization of common logics and, therefore, increases maintainability.

### Modularity Within Business Operations
> Check `BOps Documentation` for a more in-depth explanation of flows and reusing BOps inside another BOps.

Each step of the flow in a Business Operation is a function that chains with the next neighbor to compose the logic of the said flow.

Initially, the functions available to be used are only the built in ones, and those which were generated by a Schema (See Schema BOps Functions). However, Meta-System allows for adding new functions (from NPM packages) directly through the system configuration file. If there is anything that Meta-System currently does not do, you can create any new function that suits your needs, or download compatible solutions from the NPM registry.

We treat this topic more in depth in the `Extending Meta-System Functionality` page.
